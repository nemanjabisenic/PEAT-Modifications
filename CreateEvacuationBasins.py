"""
CreateWatersheds.py

J.M. Jones, jmjones@usgs.gov

initial version:  Oct 2017 (v1.1), updated Jul 2022 (python3), updated Jun 2023 (v2)

Usage:  createTheBasins(ingdb, roadlines, pop_points, pop_count)

Required Arguments:   ingdb - local database workspace (existing file geodatabase)
                      roadlines - polyline feature class of the roads for evacuation

Optional Arguments:   pop_points - point feature class of population locations
                      pop_count - column name in attribute table that contains population counts for each point,
                                  this column can be either integer or decimal

Description:
 Creates the watersheds / basins for evacuation flow from the path distance raster generated by the path distance tool
 and run through flow direction and flow accumulation.  It works both with population points and with no population.  Flow
 lines are also generated.

Assumptions:
  This tool will only be run for a roads-only scenario (no full landscape).

Returns:  Within the PEATbasin folder in the project raster storage, the cost inverse, path distance, and flow direction
          rasters are stored from the roads-only processing.  A flow accumulation raster shows the evacuation paths
          along with counts (if entered), the pour point raster shows the locations where the evacuation paths cross
          into the safe zone, and the watersheds raster shows the boundaries of each 'evacuation' shed generated
          from the flow accumulation processing. Vector versions of the flow lines, pour points, and watersheds are
          stored in the project feature storage along with a watershed boundary feature class.  The watershed
          boundary is the minimum bounding geometry (convex hull) of each watershed to help with visualization.

This software has been approved for release by the U.S. Geological Survey (USGS).
Although the software has been subjected to rigorous review, the USGS reserves the
right to update the software as needed pursuant to further analysis and review. No
warranty, expressed or implied, is made by the USGS or the U.S. Government as to the
functionality of the software and related material nor shall the fact of release
constitute any such warranty. Furthermore, the software is released on condition that
neither the USGS nor the U.S. Government shall be held liable for any damages resulting
from its authorized or unauthorized use.
"""
import os, traceback
import arcpy
from PEATutil import EvacUtilities as util
from PEATutil import PEATnames as names
from makeBasinRoads import makeRoadsForBasins
from runFlowAccumulation import getFlowAccumulation
from runDistanceAccumulation import runDistAcc

# Inputs are screened for existence and appropriate data type in the ArcPro tool window parameter settings.
def createTheBasins(ingdb, inroads, popfile, popcol):
    try:
        arcpy.env.overwriteOutput = True
        arcpy.env.workspace = ingdb

        # get gdb file names and check that the files are in the project gdb
        scenario = 'PEATbasin'
        elevation = util.checkForTheFile(ingdb, 'elevation', filetype='raster' )
        studyareaR = util.checkForTheFile(ingdb, 'studyareaR', filetype='raster' )
        studyareaV = util.checkForTheFile(ingdb, 'studyareaV',filetype='vector' )
        safezoneR = util.checkForTheFile(ingdb, 'safezoneR', filetype='raster')

        # Set environment variables based on dem and study area
        arcpy.env.extent = arcpy.Describe(studyareaR).Extent
        arcpy.env.snapRaster = elevation
        cellsize, demsr = util.getRasterCellAndSR( elevation )
        arcpy.env.outputCoordinateSystem = demsr
        arcpy.env.cellSize = cellsize

        # Get new names
        roadlines = util.getFeatureStorage(ingdb,util.getPEATfileName('roadlines'),names.BASIN,scenario,demsr)
        population = util.getFeatureStorage(ingdb,util.getPEATfileName('population'),names.BASIN,scenario,demsr)

        #Determine the scenario to use for basins (pop / no pop).  If population, lines will need to be generated
        #that connect the points to the road network and path distance will need to be rerun to get a new backlink
        #raster.  For population, the pop points are used as weights for flow accumulation.  For no population,
        #the midpoints of each line segment are generated to use as weights.  This is preferable to no weights at
        #all, since no weights causes flow accumulation to count cells that are traveled through and this sum
        #can become quite large.
        util.screenInputVector(ingdb,inroads,demsr,studyareaV,roadlines)
        if popfile:
            util.screenInputVector(ingdb,popfile,demsr,studyareaV,population)
            pathdist, popraster = makeRoadsForBasins(ingdb, scenario, roadlines, population, popcol)
        else:
            pathdist, popraster = makeNewRoadsAndPopulationPoints(ingdb,scenario,roadlines,cellsize)

        # use flow accumulation in order to get all pour point connections with the safe zone and a count
        # of the number of people arriving at each location (for population scenario).  If no pop, the final count
        # is not used.
        flowacc,flowlines,flowdir = getFlowAccumulation(ingdb, scenario, pathdist, popraster)
        util.cleanUpIntermediateFiles([popraster])

        # mask the flow accumulation by the safe raster to get only the final cell counts of each
        # flow line and convert to integer to get a raster and vector of pour points
        pourpoints, pour_vector = getPourPoints(ingdb,scenario,flowacc,safezoneR)

        # create watersheds using the reclassed backlink and the pourpoint raster with cells at the
        # intersection of the time map and the safe zone for the pour points
        shedboundary = makeTheWatersheds(ingdb, scenario, flowdir, pourpoints)

        arcpy.AddMessage("Pour points have been stored at {0}".format(os.path.join(ingdb, pour_vector)))
        arcpy.AddMessage("Flow lines have been stored at {0}".format(os.path.join(ingdb, flowlines)))
        arcpy.AddMessage("Watershed boundaries have been stored at {0}".format(os.path.join(ingdb, shedboundary)))
        return pour_vector, flowlines, shedboundary

    except arcpy.ExecuteError:
        arcpy.AddError(arcpy.GetMessages(2))
        raise
    except util.JustExit:
        raise
    except Exception:
        arcpy.AddError(traceback.format_exc())
        raise

# In place of actual population points, create points throughout the hazard zone by converting the roadlines to
# feature verticies (including the midpoints of the lines) and use these for weighting the flow accumulation.  This
# also uses the current roads to run path distance for creating the flow direction raster.
def makeNewRoadsAndPopulationPoints(ingdb,scenario,roadlines,cellsize):
    try:
        arcpy.env.overwriteOutput = True

        # get names needed to run new distance accumulation
        safezoneR = util.getRasterStorage(ingdb, util.getPEATfileName('safezoneR'),names.ROOT)
        costinv = util.getRasterStorage(ingdb, "{0}_{1}".format(util.getPEATfileName("costinv"),scenario),
                                        names.BASIN,scenario)
        pathdist = util.getRasterStorage(ingdb,"{0}_{1}".format(util.getPEATfileName("pathdist"),scenario),
                                         names.BASIN,scenario)
        backlink = util.getRasterStorage(ingdb,"{0}_{1}".format(util.getPEATfileName("backlink"),scenario),
                                         names.BASIN,scenario)

        # make pop points from roadline midpoints
        popvector = util.getFeatureStorage(ingdb,"nopop_points",names.SCRATCH)
        popraster = util.getRasterStorage(ingdb, "nopop_raster",names.SCRATCH)
        util.cleanUpIntermediateFiles([popraster])
        arcpy.FeatureVerticesToPoints_management(roadlines, popvector, "MID")
        arcpy.AddField_management(popvector, "POPINT", "LONG")
        arcpy.CalculateField_management(popvector, "POPINT", 1)
        arcpy.PointToRaster_conversion(popvector, "POPINT", popraster, "MINIMUM", "", cellsize)
        util.cleanUpIntermediateFiles([popvector])

        # Create a new cost inverse raster from the original roads layer (with scv=1).
        startcost = util.getRasterStorage(ingdb,'startcost',names.SCRATCH)
        costtemp = util.getRasterStorage(ingdb, 'costtemp', names.SCRATCH)
        fieldname = arcpy.Describe(roadlines).OIDFieldName
        arcpy.FeatureToRaster_conversion(roadlines, fieldname, startcost, str(cellsize))
        arcpy.CheckOutExtension("Spatial")
        outSlice = arcpy.sa.Slice(startcost, 1, "EQUAL_INTERVAL", base_output_zone=1)
        outSlice.save(costtemp)
        arcpy.CalculateStatistics_management(costtemp)
        outnull = arcpy.sa.SetNull(costtemp,costtemp,"VALUE = 0")
        outnull.save(costinv)
        arcpy.CheckInExtension("Spatial")
        arcpy.CalculateStatistics_management(costinv)
        util.cleanUpIntermediateFiles([startcost,costtemp])

        # Run Distance Accumulation to create a distance raster for flow accumulation
        runDistAcc(ingdb, safezoneR, costinv, pathdist, backlink)

        return pathdist, popraster

    except arcpy.ExecuteError:
        arcpy.AddError(arcpy.GetMessages(2))
        raise
    except Exception:
        arcpy.AddError(traceback.format_exc())
        raise

# Masks the flow accumulation raster by the safe zone to get the cells of flow accumulation right as the flow enters
# the safe zone.  These raster cells (pour points) contain the values of the accumulated flow along the flowpath.  The
# pour points are then converted to vector and both formats are returned.
def getPourPoints(ingdb, scenario, flow, safezone):
    try:
        arcpy.env.overwriteOutput = True
        tempmask = util.getRasterStorage(ingdb, "flowmask",names.SCRATCH)
        pourpointsR = util.getRasterStorage(ingdb, "{0}_{1}".format(util.getPEATfileName("pourpointsR"),scenario),
                                                names.BASIN,scenario)
        nullmask = util.getRasterStorage(ingdb, "nullmask",names.SCRATCH)
        util.cleanUpIntermediateFiles([tempmask,pourpointsR,nullmask])

        arcpy.CheckOutExtension("Spatial")
        outmask = arcpy.sa.ExtractByMask(flow, safezone)
        outmask.save(tempmask)
        outint = arcpy.sa.Int(tempmask)
        outint.save(nullmask)
        outnull = arcpy.sa.SetNull(nullmask, nullmask, "VALUE = 0")
        outnull.save(pourpointsR)
        arcpy.CheckInExtension("Spatial")
        util.cleanUpIntermediateFiles([tempmask,nullmask])

        pourpointsV = util.getFeatureStorage(ingdb,"{0}_{1}".format(util.getPEATfileName('pourpointsV'),scenario),
                                             names.BASIN,scenario)
        arcpy.RasterToPoint_conversion(pourpointsR, pourpointsV, "Value")

        return pourpointsR, pourpointsV

    except arcpy.ExecuteError:
        arcpy.AddError(arcpy.GetMessages(2))
        raise
    except Exception:
        arcpy.AddError(traceback.format_exc())
        raise

# The Watershed tool is run on the flow direction raster and the pour points to identify the watersheds that
# empty into each pour point. To get a better picture of the watersheds, the minimum bounding geometry (convex hull)
# is used to show the areas.
def makeTheWatersheds(ingdb, scenario, reblink, pourpoints):
    try:
        arcpy.AddMessage("Creating watersheds...")
        watersheds =  util.getRasterStorage(ingdb,"{0}_{1}".format(util.getPEATfileName("watershedsR"),scenario),
                                            names.BASIN,scenario)
        util.cleanUpIntermediateFiles([watersheds])
        arcpy.CheckOutExtension("Spatial")
        outshed = arcpy.sa.Watershed( reblink, pourpoints,"Value")
        outshed.save( watersheds )
        arcpy.CheckInExtension("Spatial")

        # convert each value in the watersheds raster to a polygon
        shedspoly = util.getFeatureStorage(ingdb,"{0}_{1}".format(util.getPEATfileName("watershedsV"),scenario),
                                           names.BASIN,scenario)
        shedsoutline = util.getFeatureStorage(ingdb,"{0}_{1}".format(util.getPEATfileName("watershedsbounding"),scenario),
                                            names.BASIN,scenario)
        arcpy.RasterToPolygon_conversion( watersheds, shedspoly, "NO_SIMPLIFY", "VALUE",max_vertices_per_feature=100000)
        arcpy.MinimumBoundingGeometry_management(shedspoly, shedsoutline, "CONVEX_HULL")

        return shedsoutline

    except arcpy.ExecuteError:
        arcpy.AddError(arcpy.GetMessages(2))
        raise
    except Exception:
        arcpy.AddError(traceback.format_exc())
        raise


if __name__ == "__main__":
    try:
        start_gdb = arcpy.GetParameterAsText(0)
        start_roadlines = arcpy.GetParameterAsText(1)
        start_popfile = arcpy.GetParameterAsText(2)
        start_popcol = arcpy.GetParameterAsText(3)
        endpoints,endlines,endsheds = createTheBasins(start_gdb, start_roadlines, start_popfile, start_popcol)
        util.addLayerToMap(start_gdb,endpoints, "pourpoints")
        util.addLayerToMap(start_gdb, endlines, "flowlines")
        util.addLayerToMap(start_gdb, endsheds, "watersheds")
    except Exception:
        arcpy.SetParameterAsText(0, False)
